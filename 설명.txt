
### 행동 패턴(Behavioral Patterns)
01.ChainOfResp.
02.Command.
03.Interpreter.
04.Iterator.
05.Mediator.

### ChainOfResp(Chain of Responsiblity )
# def
Chain of Responsiblity 패턴은 느슨하게 결합 된 개체의 사슬을 제공하며 
그 중 하나가 요청을 충족 할 수 있다.

이 패턴은 기본적으로 특정 요청을 다룰 수 있는 객체에 대한 선형검색이다.

예로 event-bubbling을 들수 있다. 
(선택한 이벤트가 중첩된 컨트롤들을 통해서 event propagates되는 것)

Chain of Responsiblity 패턴은 JavaScript에서 자주 사용하는 Chaining Pattern과 관련이 깊다 
특히 jQuery에서 많이 사용하고 있다. 

# 코드 설명

이 예제는 하나가 아니라 모든 핸들러가 요청을 처리하는데 참여한다는 점에서 고전적인 Chain of Responsiblity 패턴과 약간 다르다.

이 코드는 현금 인출기 문제에 대한 꽤 좋은 해결책을 보여줍니다. 
고객이 ATM 기계에서 247 달러를 요구한다고 가정했을때
해당 요청을 충족하는 지폐 조합($ 100, $ 50, $ 20, $ 10, $ 5, $ 1)이 무엇일지 구하는 것이다.

요청 된 금액으로 요청이 생성된다.
다음으로 일련의 get 호출이 함께 연결되어 각 호출이 특정 단위를 처리한다.
각 핸들러는 지급되는 지폐의 수를 결정하고 나머지 금액에서이 금액을 뺀다.
요청 객체는 get 메서드에서이를 반환하여 체인을 통해 전달됩니다.

log 기능은 결과를 수집하고 표시하는 도와주는 함수다.



---
### Command

# Summary
명령 패턴은 작업을 개체로 캡슐화한다.

Command 객체는 실제로 요청을 처리하는 객체와 분리한 객체들들은 느슨한 결합 시스텝을 허용한다.
명령 개체는 실제로 요청을 처리하는 개체와 요청을 발생하는 개체를 분리하여 느슨하게 결합 된 시스템을 가능하게 한다.
이러한 요청을 이벤트라고하고 요청을 처리하는 코드를 이벤트 핸들러라고한다.

만약 클립보드 잘라 내기, 복사 및 붙여 넣기 작업을 지원하는 응용 프로그램을 만든다고 했을때 
이러한 작업은 메뉴 시스템, 컨텍스트 메뉴(예 : 텍스트 상자를 마우스 오른쪽 버튼으로 클릭) 또는 키보드 단축키를 통해 앱 전체에서 다양한 방식으로 트리거할 수 있습니다. 
명령 개체를 사용하면 각 작업에 대해 하나씩 이러한 작업의 처리를 중앙 집중화 할 수 있다.

따라서 모든 잘라 내기 요청을 처리하기 위해 하나의 명령, 모든 복사 요청에 대해 하나, 모든 붙여 넣기 요청에 대해 하나만 필요합니다.
명령은 모든 처리를 중앙 집중화하기 때문에 전체 응용 프로그램의 실행 취소 기능(un do)을 처리하는데도 자주 관련됩니다.


# code 설명

이 예에는 더하기, 빼기, 곱하기 및 나누기의 4 가지 기본 연산이있는 계산기가 있다.
각 작업은 Command 개체로 캡슐화된다.

계산기는 명령 스택을 유지합니다. 각각의 새 명령이 실행되고 스택에 푸시된다.
실행 취소 요청이 도착하면 스택에서 마지막 명령을 꺼내고 역 동작을 실행한다.

JavaScript의 함수 객체 (및 콜백)는 기본 명령 객체다
그것들은 물체처럼 전달 될 수 있습니다. 사실, 그것들은 진정한 대상이다.
JavaScript의 이벤트 시스템과 콜백 작동 방식에 대해 자세히 알아 보려면 JavaScript + jQuery 디자인 패턴 프레임 워크를 살펴 보는 것이 좋습니다.


---
### Interpreter
# Summery
인터프리터 패턴은 최종 사용자가 솔루션을 사용자 지정할 수있는 스크립팅 언어를 제공한다.
일부 응용 프로그램은 너무 복잡하여 고급 구성이 필요하다. 
최종 사용자가 간단한 지침을 통해 애플리케이션을 조작 할 수있는 기본 스크립팅 언어를 제공 할 수 있다.

인터프리터 패턴은 이 특정 문제, 즉 간단한 스크립팅 언어를 만드는 문제를 해결한다.
특정 유형의 문제는 언어에 의해 특성화된다.
이 언어는 잘 이해되고 잘 정의되어야하는 문제 영역을 설명한다. 
이를 구현하려면 언어를 문법에 매핑해야한다. 
문법은 일반적으로 여러 단계를 거쳐 터미널 노드 (리터럴이라고도 함)로 끝나는 계층 적 트리 구조입니다.

문법으로 표현되는 이와 같은 문제는 인터프리터 디자인 패턴을 사용하여 구현할 수 있다.
오늘날 JavaScript에서 이러한 유형의 제어가 정말로 필요한 경우 ANTLR과 같은 코드 생성기를 사용하면 
제공하는 문법을 기반으로 자신 만의 명령 Interpreter를 구축하는 것이 더 쉬울 것이다.


# code 설명
Context 객체는 로마숫자 input을 유지한다. 그리고 out의 결과는 번역객체에 의해서 번역된 것이다.
Expression 개체는 문법 tree 배열의 노드를 나타냅니다. tree 배열을 순회하면서 interpret을 지원한다.
프로그램을 실행 시켰을때 비슷한 tree 문법은 로마숫자 그리고 십진수 숫자 번역으로 만들어 진것이다.





---
# Summary
The Iterator pattern allows clients to effectively loop over a collection of objects
Iterator 사용자가 순회를 효과적으로 할 수 있도록 도와주는 객체의 collection 이다.

A common programming task is to traverse and manipulate a collection of objects. 
흔한 프로그램밍 업무는 객체 colleciton을 순회하며 객체는 다루는 것이다.

이러한 collection은 배열로 저장되거나 트리 또는 그래프 구조와 같이 더 복잡한 것으로 저장 될 수 있다.
또한 컬렉션의 항목에 앞뒤, 뒤에서 앞, 깊이 우선 (트리 검색에서와 같이), 균등 번호 개체 건너 뛰기 등과 같은 특정 순서로 액세스해야 할 수도 있습니다.

반복자 디자인 패턴은 특수 Iterators를 구현하여 이러한 개체의 순회에서 개체 컬렉션을 분리하여이 문제를 해결합니다.

오늘날 많은 언어에는 'for-each'유형 구조와 IEnumerable 및 IEnumerator 인터페이스를 지원하여 Iterators가 내장되어 있습니다. 
그러나 JavaScript는 for, for-in, while 및 do while 문 형식의 기본 루프 만 지원합니다.

Iterator 패턴을 사용하면 JavaScript 개발자가 훨씬 더 유연하고 정교한 루프 구조를 설계 할 수 있습니다.

# code 설명

The Iterator object maintains a reference to the collection and the current position. 
Iterator객체는 collection과 현재 position 관리한다.

'standard' Iterator interface는 first, next, hasNext, reset, and each 이것들을 구현한다.

Two looping methods are used: a built-in for loop and a newly created each method. 
두개의 순회 함수는 내장된 loop와 새로 만든 방식의 함수이다.

새로 만든 방식은 순회는 first, hasNext, and next 함수로 제어한다.

내부적으로 구현한것도 같은 방법이기는(for loop를 실행) 하나 syntax가 훨씬 간소해졌다.


---
# Mediator

Summary
The Mediator pattern provides central authority over a group of objects by encapsulating how these objects interact. 
Mediator 패턴은 객체간의 그룹에 중앙 권력을 할수 있도록 한다.(객체들이 어떻게 interact하는지에 대해서 캡슐화에 의해서)

This model is useful for scenarios where there is a need to manage complex conditions in which every object is aware of any state change in any other object in the group.
이 모델은 복잡한 조건들을 다루는 것이 필요로 하는 시나리오에서 유용한다.
	- 위 조건들은 서로 어떤 state가 변하는지 알아야 한다.

Mediator 패턴은 복잡한 forms에서 유용하다.
항공권을 예매하기위해서 욥선을 선택할때 예를 들수 있다.
간단한 중재자 규칙은 다음과 같다. 유효한 출발 날짜, 유효한 귀국 날짜를 입력해야하며 귀국 날짜는 출발 날짜 이후 여야하며 유효한 출발 공항, 유효한 도착 공항, 유효한 여행자 수를 입력해야합니다. 검색 버튼을 활성화 할 수 있다.

Mediator의 또 다른 예는 비행기의 도착과 출발을 조정하는 공항의 관제탑입니다.


# Sample code in JavaScript
예제 코드에는 Chatroom (중재자)에 등록하여 채팅 세션에 참여하는 4 명의 참가자가 있습다
각 참가자는 Participant 개체로 표시한다.
참가자는 서로에게 메시지를 보내고 Chatroom에서 routing 처리합니다.
이 예는 간단하지만 참가자가 정크 메시지를받지 못하도록 보호하는 '정크 필터'와 같은 다른 복잡한 규칙을 추가 할 수 있습니다.




06.Memento.
07.Observer. 
	ㄴ [ ] 마우스, 키보드에 fire되는 Observer 패턴 추가 구현하기
08.State.
09.Strategy.
10.Template Method.
	ㄴ [ ] 추가하기 구멍이있는 알고리즘이다. (아래 다이어그램 참조). 
11.Visitor.
	ㄴ [ ] 이러한 유연성과 이것이 JavaScript 패턴 및 패턴 아키텍처에 어떻게 도움이되는지 자세히 알아 보려면 JavaScript + jQuery 디자인 패턴 프레임 워크를 참조하십시오.
[ ] 회사에서 어떤 디자인 패턴을 사용했는지 분석하기 

---

# Memento.
## 요약
Memento 패턴은 개체의 복원뿐만 아니라 임시 저장소를 제공한다. 
객체의 상태를 저장하는 메커니즘은 필요한 지속 기간에 따라 다르며 다를 수 있습니다.

개체가 유지되고 복원되는 Memento 디자인 패턴의 구현으로 데이터베이스를 생각할 수 있다.
그러나 이 패턴을 사용하는 가장 일반적인 이유는 
필요한 경우 후속 변경 사항을 쉽게 취소 할 수 있도록 객체 상태의 스냅 샷을 캡처하는 것이다.

기본적으로 Memento는 개체의 상태를 저장하는 작은 저장소이다.
개체를 이전에 존재했던 상태로 복원하려는 시나리오에는 
컴퓨터 게임에서 플레이어의 상태 저장 및 복원 또는 데이터베이스에서 실행 취소 작업 구현이 포함된다.

JavaScript에서 Mementos는 JSON으로 객체를 serializing, de-serializing해서 쉽게 구현할 수 있다.

## 코드 설명
샘플 코드에서 Mike, John 은 Person 생성자 함수를 사용하여 생성된다.
그리고 CareTaker 개체가 유지 관리하는 Mediator가 생성됩니다.

유품에서 복원하기 전에 Mike와 John의 가짜 이름을 
복원 후 우리는 사람 개체가 유효한 이름으로 원래 상태로 돌아 왔는지 확인한다.

CareTaker 등의 Memento 패턴 자체는 JavaScript에서 거의 사용되지 않는다.
그러나 JSON은 다양한 데이터 교환 시나리오에서 매우 유용한 매우 효과적인 데이터 형식이다.


# Observer.
## 요약
Observer 패턴은 개체가 이벤트를 구독하고 이벤트 발생시 알림을받는 구독 모델을 제공한다.
이 패턴은 JavaScript를 포함한 이벤트 기반 프로그래밍의 초석이다. 
Observer 패턴은 좋은 객체 지향 설계를 용이하게하고 느슨한 결합을 촉진시킨다.

웹 앱을 빌드 할 때 많은 이벤트 핸들러를 작성하게된다.
이벤트 핸들러는 특정 이벤트가 발생할 때 알림을받는 함수이다.
이러한 알림은 선택적으로 이벤트에 대한 세부 정보 (클릭 이벤트에서 마우스의 x, y position정보와 함께 이벤트 받는다.)

JavaScript의 이벤트 및 이벤트 처리기 패러다임은 Observer 디자인 패턴의 표현입니다. 
Observer 패턴의 또 다른 이름은  Pub/Sub이다 (Publication/Subscription 의 짦은 표현이다)

## 코드 설명
Click 개체는 관찰자 입니다.(clickHandler함수를 subScribe, unsubscribe한다) 나타낸다. 
clickHandler 함수는 구독되는 대상이다. 
이 핸들러는 이벤트가 발생하는 동안 구독, 구독 취소 한 다음 자체 구독한다.
이벤트 # 1 및 # 3에 대해서만 알림을받는다.

fire 메서드는 두 개의 인수를받는다. 
첫 번째는 이벤트에 대한 세부 정보를 가지고 있고 
두 번째는 컨텍스트, 즉 이벤트 핸들러가 호출 될 때의 this 값이다. 
컨텍스트가 제공되지 않으면 전역 개체(window)에 바인딩된다.



# State.
## 요약
* State 패턴은 각 개체가 특정 상태를 나타내는 제한된 개체 집합에 상태 별 로직을 제공한다.

* 고객이 온라인으로 TV를 주문한다고 가정했을 때
* 이 주문이 처리되는 동안 new, 승인, 포장, 보류 중, 보류, 배송, 완료 됨 또는 취소됨 중 하나 일 수 있습니다.
* 모든 것이 순조롭게 진행되면 순서는 신규, 승인 됨, 포장 됨, 배송 됨 및 완료가 된다.
* 그러나 언제든지 재고 없음, 파손 또는 고객 취소와 같은 예측 할 수없는 일이 발생할 수 있다.
* 이 경우 주문을 적절하게 처리해야 한다.
* 이 시나리오에 상태 패턴을 적용하면 각각 고유 한 속성(상태), 메서드(즉, 허용 가능한 상태 전환 규칙)집합이있는 8개의 상태 개체가 제공된다.
* 상태 머신은 종종 상태 패턴을 사용하여 구현된다.
* 이러한 상태 머신은 상태 전환이 발생할 때 단순히 상태 객체를 다른 객체로 교체한다.

* State 패턴이 유용한 다른 두 가지 예는
* 동전의 올바른 조합이 입력 될 때 제품을 주는 자동 판매기와 
* 엘레베이터가 움직이는 시간과 대기시간을 최소화하려는 특정 복잡한 규칙에 따라 탑승자를 위아래로 움직이는 엘리베이터 로직이 있다.

## 코드 설명
* 각각 고유 한 규칙 집합이있는 빨간색, 노란색 및 녹색의 세 가지 상태가있는 신호등(예TrafficLight 개체)이 있다.
* 규칙은 다음과 같다. 신호등이 빨간색이라고 가정했을때 지연 후 빨간색 상태가 녹색 상태로 변경된다.
* 그런 다음 다른 지연 후 녹색 상태가 노란색 상태로 변경된다.
* 잠시 후 노란색 상태가 빨간색으로 변경된다.

* 그리고 계속해서 다음 상태로의 전환을 결정하는 것은 State 객체라는 점에 유의해야한다.
* 또한 TrafficLight 자체가 아니라 TrafficLight의 현재 상태를 변경하는 것은 State 개체(Red, Yellow, Green 객체)다.

* 데모 목적으로 내장 카운터는 상태 변경 수를 제한한다. 
* 그렇지 않으면 프로그램이 무기한 실행된다.


# Strategy.
## 요약
* 전략 패턴은 특정 작업에 대한 대체 알고리즘 (또는 전략)을 캡슐화한다.
* 이를 통해 클라이언트가 인식하지 못한 채 다른 방법 (전략)에 의해 런타임에 메서드를 교체 할 수 있다.
* 기본적으로 전략은 상호 교환 가능한 알고리즘 그룹이다.

* 쉘 정렬, 힙 정렬, 버블 정렬, 퀵 정렬 등과 ​​같은 숫자 배열에 대해 다른 정렬 알고리즘의 성능을 테스트하고 싶다고 가정해 본다.
* 이러한 알고리즘에 전략 패턴을 적용하면 테스트 프로그램이 모든 알고리즘을 간단히 변경할 수 있다.
* 런타임에 이들 각각을 배열에 대해 테스트한다.
* 전략이 작동하려면 모든 메소드 서명이 동일해야 클라이언트 프로그램이 알지 못하는 사이에 다를 수 있다
 
* JavaScript에서 전략 패턴은 확장 가능한 프레임 워크를 빌드 할 때 플러그인 메커니즘으로 널리 사용된다.
* 이것은 매우 효과적인 접근 방법이 될 수 있다. 


## 코드 설명
* 창고에서 고객에게 배송해야하는 제품 주문이 있다. 
* 최상의 가격을 결정하기 위해 여러 운송 회사가 평가된다. 
* 이는 고객이 배송 선호도를 선택하고 선택한 전략이 예상 비용을 반환하는 쇼핑 카트에 유용 할 수 있다.

* 배송은 컨텍스트이며 UPS, USPS 및 Fedex의 3 개 배송 회사가 전략이다. 
* 운송 회사 (전략)는 3 번 변경되며 매번 운송 비용을 계산한다. 
* 실제 시나리오에서 계산 방법은 발송인의 웹 서비스를 호출 할 수 있다. 
* 마지막에 우리는 다른 비용을 표시한다.



# Template Method.
## 요약
* 템플릿 방법 패턴은 알고리즘에 대한 일련의 단계 개요를 ​제공한다.
* 이러한 단계를 구현하는 객체는 알고리즘의 원래 구조를 유지하지만 특정 단계를 재정의하거나 조정할 수있는 옵션이 있다.
* 이 패턴은 클라이언트 개발자에게 확장성을 제공하도록 설계되어 있다.

* 템플릿 메서드는 다른 개발자가 사용할 범용 프레임 워크 또는 라이브러리에서 자주 사용된다.
* 예제는 프로세스 요청과 같은 작업에 대한 응답으로 일련의 이벤트를 발생시키는 개체이다. 
* 객체는 '전처리'이벤트, '프로세스'이벤트 및 '후 처리'이벤트를 생성합니다.
* 개발자는 처리 직전, 처리 중 및 처리 직후에 응답을 조정할 수있는 옵션이 있다.

* 템플릿 방법을 쉽게 생각할 수있는 방법은 구멍이있는 알고리즘이다. (아래 다이어그램 참조). 
* 각 단계에 적절한 기능으로 이러한 구멍을 채우는 것은 개발자의 몫이다.

## 코드 설명
* 여기에 JavaScript의 프로토타입 상속을 사용하는 예가 있다.
* 상속 기능은 새로 생성 된 하위 개체의 프로토타입에 기본개체를 할당하여 상속 관계를 설정하는데 도움이 된다.

* 데이터 저장소 함수는 AbstractClass를 나타내고 mySql은 ConcreteClass를 나타낸다.
* mySql은 데이터 스토어 별 구현으로 연결, 선택 및 연결 해제의 세 가지 템플릿 메서드를 재정의한다.

* 템플릿 메서드를 사용하면 클라이언트가 템플릿 메서드만(connect, select, disconnect) 작성하여 데이터 저장소 (SQL Server, Oracle 등)를 변경할 수 있다. 
* 단계 순서와 같은 나머지는 모든 데이터 스토어에서 동일하게 유지된다.



# Visitor.
## 요약
* 방문자 패턴은 개체 자체를 변경하지 않고 개체 컬렉션에 대한 새 작업을 정의한다.
* 새 논리는 방문자라는 별도의 개체에 있다.
* 방문자는 라이브러리 또는 프레임 워크에서 확장 성을 구축 할 때 유용하다.
* 프로젝트의 객체가 수신 객체를 변경할 수있는 Visitor 객체를 허용하는 '방문'메소드를 제공하는 경우 클라이언트가 향후 확장을 구현할 * 수있는 쉬운 방법을 제공하는 것이다.
* 대부분의 프로그래밍 언어에서 방문자 패턴은 원래 개발자가 향후 기능 조정을 예상 할 것을 요구한다.
* 이것은 방문자를 받아들이고 원래 개체 컬렉션에서 작동하도록하는 메서드를 포함하여 수행된다.
* 방문자는 런타임에 메소드를 추가하고 제거하는 기능으로 훨씬 더 많은 유연성을 제공하기 때문에 JavaScript에 중요하지 않다.


## 코드 설명
* Employee 생성자 함수를 사용하여 세 명의 직원이 생된다.
* 각각은 10 %의 급여 인상과 2 일 더 휴가를 받는다.

* 두 방문자 개체 인 ExtraSalary 및 ExtraVacation은 직원 개체에 필요한 변경을 수행한다.
* 방문자는 방문 방법에서 공개 인터페이스를 통해 클로저 변수 salary, vacation에 액세스한다.
* 클로저는 외부에서 접근 할 수 없기 때문에 유일한 방법이다.
* 실제로 클로저 변수 salary, vacation 급여와 휴가는 변수가 아니라 함수 인수이지만 클로저의 일부이기 때문에 작동한다.

* self 변수에 주목해야한다. 
* 현재 컨텍스트(클로저 변수로 저장 됨)를 유지하는 데 사용되며 방문 방법에 사용된다.

----------------
