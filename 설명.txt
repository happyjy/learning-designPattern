### Chain of Responsiblity 
# def
Chain of Responsiblity 패턴은 느슨하게 결합 된 개체의 사슬을 제공하며 
그 중 하나가 요청을 충족 할 수 있다.

이 패턴은 기본적으로 특정 요청을 다룰 수 있는 객체에 대한 선형검색이다.

예로 event-bubbling을 들수 있다. 
(선택한 이벤트가 중첩된 컨트롤들을 통해서 event propagates되는 것)

Chain of Responsiblity 패턴은 JavaScript에서 자주 사용하는 Chaining Pattern과 관련이 깊다 
특히 jQuery에서 많이 사용하고 있다. 

# 코드 설명

이 예제는 하나가 아니라 모든 핸들러가 요청을 처리하는데 참여한다는 점에서 고전적인 Chain of Responsiblity 패턴과 약간 다르다.

이 코드는 현금 인출기 문제에 대한 꽤 좋은 해결책을 보여줍니다. 
고객이 ATM 기계에서 247 달러를 요구한다고 가정했을때
해당 요청을 충족하는 지폐 조합($ 100, $ 50, $ 20, $ 10, $ 5, $ 1)이 무엇일지 구하는 것이다.

요청 된 금액으로 요청이 생성된다.
다음으로 일련의 get 호출이 함께 연결되어 각 호출이 특정 단위를 처리한다.
각 핸들러는 지급되는 지폐의 수를 결정하고 나머지 금액에서이 금액을 뺀다.
요청 객체는 get 메서드에서이를 반환하여 체인을 통해 전달됩니다.

log 기능은 결과를 수집하고 표시하는 도와주는 함수다.



---
### Command

# Summary
명령 패턴은 작업을 개체로 캡슐화한다.

Command 객체는 실제로 요청을 처리하는 객체와 분리한 객체들들은 느슨한 결합 시스텝을 허용한다.
명령 개체는 실제로 요청을 처리하는 개체와 요청을 발생하는 개체를 분리하여 느슨하게 결합 된 시스템을 가능하게 한다.
이러한 요청을 이벤트라고하고 요청을 처리하는 코드를 이벤트 핸들러라고한다.

만약 클립보드 잘라 내기, 복사 및 붙여 넣기 작업을 지원하는 응용 프로그램을 만든다고 했을때 
이러한 작업은 메뉴 시스템, 컨텍스트 메뉴(예 : 텍스트 상자를 마우스 오른쪽 버튼으로 클릭) 또는 키보드 단축키를 통해 앱 전체에서 다양한 방식으로 트리거할 수 있습니다. 
명령 개체를 사용하면 각 작업에 대해 하나씩 이러한 작업의 처리를 중앙 집중화 할 수 있다.

따라서 모든 잘라 내기 요청을 처리하기 위해 하나의 명령, 모든 복사 요청에 대해 하나, 모든 붙여 넣기 요청에 대해 하나만 필요합니다.
명령은 모든 처리를 중앙 집중화하기 때문에 전체 응용 프로그램의 실행 취소 기능(un do)을 처리하는데도 자주 관련됩니다.


# code 설명

이 예에는 더하기, 빼기, 곱하기 및 나누기의 4 가지 기본 연산이있는 계산기가 있다.
각 작업은 Command 개체로 캡슐화된다.

계산기는 명령 스택을 유지합니다. 각각의 새 명령이 실행되고 스택에 푸시된다.
실행 취소 요청이 도착하면 스택에서 마지막 명령을 꺼내고 역 동작을 실행한다.

JavaScript의 함수 객체 (및 콜백)는 기본 명령 객체다
그것들은 물체처럼 전달 될 수 있습니다. 사실, 그것들은 진정한 대상이다.
JavaScript의 이벤트 시스템과 콜백 작동 방식에 대해 자세히 알아 보려면 JavaScript + jQuery 디자인 패턴 프레임 워크를 살펴 보는 것이 좋습니다.


---
### Interpreter
# Summery
인터프리터 패턴은 최종 사용자가 솔루션을 사용자 지정할 수있는 스크립팅 언어를 제공한다.
일부 응용 프로그램은 너무 복잡하여 고급 구성이 필요하다. 
최종 사용자가 간단한 지침을 통해 애플리케이션을 조작 할 수있는 기본 스크립팅 언어를 제공 할 수 있다.

인터프리터 패턴은 이 특정 문제, 즉 간단한 스크립팅 언어를 만드는 문제를 해결한다.
특정 유형의 문제는 언어에 의해 특성화된다.
이 언어는 잘 이해되고 잘 정의되어야하는 문제 영역을 설명한다. 
이를 구현하려면 언어를 문법에 매핑해야한다. 
문법은 일반적으로 여러 단계를 거쳐 터미널 노드 (리터럴이라고도 함)로 끝나는 계층 적 트리 구조입니다.

문법으로 표현되는 이와 같은 문제는 인터프리터 디자인 패턴을 사용하여 구현할 수 있다.
오늘날 JavaScript에서 이러한 유형의 제어가 정말로 필요한 경우 ANTLR과 같은 코드 생성기를 사용하면 
제공하는 문법을 기반으로 자신 만의 명령 Interpreter를 구축하는 것이 더 쉬울 것이다.


# code 설명
Context 객체는 로마숫자 input을 유지한다. 그리고 out의 결과는 번역객체에 의해서 번역된 것이다.
Expression 개체는 문법 tree 배열의 노드를 나타냅니다. tree 배열을 순회하면서 interpret을 지원한다.
프로그램을 실행 시켰을때 비슷한 tree 문법은 로마숫자 그리고 십진수 숫자 번역으로 만들어 진것이다.





---
# Summary
The Iterator pattern allows clients to effectively loop over a collection of objects
Iterator 사용자가 순회를 효과적으로 할 수 있도록 도와주는 객체의 collection 이다.

A common programming task is to traverse and manipulate a collection of objects. 
흔한 프로그램밍 업무는 객체 colleciton을 순회하며 객체는 다루는 것이다.

이러한 collection은 배열로 저장되거나 트리 또는 그래프 구조와 같이 더 복잡한 것으로 저장 될 수 있다.
또한 컬렉션의 항목에 앞뒤, 뒤에서 앞, 깊이 우선 (트리 검색에서와 같이), 균등 번호 개체 건너 뛰기 등과 같은 특정 순서로 액세스해야 할 수도 있습니다.

반복자 디자인 패턴은 특수 Iterators를 구현하여 이러한 개체의 순회에서 개체 컬렉션을 분리하여이 문제를 해결합니다.

오늘날 많은 언어에는 'for-each'유형 구조와 IEnumerable 및 IEnumerator 인터페이스를 지원하여 Iterators가 내장되어 있습니다. 
그러나 JavaScript는 for, for-in, while 및 do while 문 형식의 기본 루프 만 지원합니다.

Iterator 패턴을 사용하면 JavaScript 개발자가 훨씬 더 유연하고 정교한 루프 구조를 설계 할 수 있습니다.

# code 설명

The Iterator object maintains a reference to the collection and the current position. 
Iterator객체는 collection과 현재 position 관리한다.

'standard' Iterator interface는 first, next, hasNext, reset, and each 이것들을 구현한다.

Two looping methods are used: a built-in for loop and a newly created each method. 
두개의 순회 함수는 내장된 loop와 새로 만든 방식의 함수이다.

새로 만든 방식은 순회는 first, hasNext, and next 함수로 제어한다.

내부적으로 구현한것도 같은 방법이기는(for loop를 실행) 하나 syntax가 훨씬 간소해졌다.


---
# Mediator

Summary
The Mediator pattern provides central authority over a group of objects by encapsulating how these objects interact. 
Mediator 패턴은 객체간의 그룹에 중앙 권력을 할수 있도록 한다.(객체들이 어떻게 interact하는지에 대해서 캡슐화에 의해서)

This model is useful for scenarios where there is a need to manage complex conditions in which every object is aware of any state change in any other object in the group.
이 모델은 복잡한 조건들을 다루는 것이 필요로 하는 시나리오에서 유용한다.
	- 위 조건들은 서로 어떤 state가 변하는지 알아야 한다.

Mediator 패턴은 복잡한 forms에서 유용하다.
항공권을 예매하기위해서 욥선을 선택할때 예를 들수 있다.
간단한 중재자 규칙은 다음과 같다. 유효한 출발 날짜, 유효한 귀국 날짜를 입력해야하며 귀국 날짜는 출발 날짜 이후 여야하며 유효한 출발 공항, 유효한 도착 공항, 유효한 여행자 수를 입력해야합니다. 검색 버튼을 활성화 할 수 있다.

Mediator의 또 다른 예는 비행기의 도착과 출발을 조정하는 공항의 관제탑입니다.


# Sample code in JavaScript
예제 코드에는 Chatroom (중재자)에 등록하여 채팅 세션에 참여하는 4 명의 참가자가 있습다
각 참가자는 Participant 개체로 표시한다.
참가자는 서로에게 메시지를 보내고 Chatroom에서 routing 처리합니다.
이 예는 간단하지만 참가자가 정크 메시지를받지 못하도록 보호하는 '정크 필터'와 같은 다른 복잡한 규칙을 추가 할 수 있습니다.



