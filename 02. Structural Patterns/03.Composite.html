<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>

<body>
  <script>
    /*
      # def
      Decorator pattern은 객체의 행동을 드라마틱하게 확장시키는 것이다.   
      runtime에 새로운 행동을 추가하는 능력은 Decorator객체가 기존 객체를 감싸면서 해낼 수 있다.  
      여러개의 decorator들은 오버라이드 또는 기능을 더 할 수 있다.  
        
      decorator은 보안 관리이다.
      - 비즈니스 객체는 인증 된 사용자의 권한에 따라 추가적으로 정보에 접근할 수 있는 특권이 부여된다.
      - 예를 들어 HR 관리자는 급여 정보를 볼 수 있도록 직원의 급여 기록이 추가 된 (즉, 장식 된) 직원 객체로 작업하게된다.

      decorator는 statically한 언어(eg, java)가 runntime에 유연함을 제공한다.  
      (complie time에 상속하는 것에 반대로) 
      그러나 Javascript는 dynamic언어라 runtime시에 객체를 확장 할 수 있다.   

      그래서 Javascript는 Decorator pattern과는 덜 관련이 있다.  
      Javascript에서는 "Extend, Mixin patterns"이 포괄하고 있다.  

      # participants
        * Client
          - decorated Component를 가르킨다.
          - code: run()
        * Component
          - 기능이 추가될 객체
          - code: User
        * Decorator
          - 참조를 유지하여 Component를 감싸는 역할을 한다.
          - Component 인터페이스역할을 하는 인터페이스를 정의한다.
          - 기능을 추가적으로 수행한다.
          - code: DecoratedUser

      # code 설명
        * User 객체는 DecorateddUser객체에 의해서 확장된다.
        * 이 확장은 User에 주소 관련 정보를 확장한다.
        * [POINT]원래 인터페이스는 그대로 있어야 하고 user.name이 this.name으로 할당 되어야한다.
        * 또한 같은 Decorateduser의 say 함수는 User의 say method를 감춘다.
        * Javascript는 자체적으로 객체를 효과적으로 확장하고 있다.
        
      # 나의 설명
        * Javascript는 runtime에도 객체에 함수를 추가 할 수 있기 때문에 java와같은 statically한 언어에서 유용한 구조 패턴이다.
        * Decorator 패턴은 기존 객체에 기능(책임)을 추가할 수 있는 패턴으로 기능이 확장이 필요할때 서브 클래싱 대힌에 유연한 대안이 될 수 있다.
    */

    var log = (function () {
      var log = '';

      return {
        add: function (msg) { log += msg + '\n' },
        show: function () { console.log(log); log = ''; }
      }
    })();

    // POINT1: Node에는 Node의 이름, 자식으로 가질 배열 변수를 갖음
    // Component, Leaf, Composite 역할
    var Node = function (name) {
      this.children = [];
      this.name = name;
    }

    Node.prototype = {
      /*
        child type: Node 객체
      */
      add: function (child) {
        // POINT2: Node의 기능으로 본인이 가질 자식 노드를 children 배열에 push
        this.children.push(child);
      },


      /*
        child type: Node 객체
      */
      remove: function (child) {
        var length = this.children.length;
        for (var i = 0; i < length; i++) {
          if (this.children[i] === child) {
            this.children.splice(i, 1);
            return;
          }
        }
      },

      /*
        i: int type
      */
      getChild: function (i) {
        return this.children[i];
      },

      hasChildren: function () {
        return this.children.length > 0;
      }
    }

    // recursively traverse a (sub)tree
    function traverse(indent, node) {
      log.add(Array(indent++).join("--") + node.name);

      for (var i = 0, len = node.children.length; i < len; i++) {
        traverse(indent, node.getChild(i));
      }
    }

    function run() {
      var tree = new Node("root");
      var left = new Node("left");
      var right = new Node("right");
      var leftleft = new Node("leftleft");
      var leftright = new Node("leftright");
      var rightleft = new Node("rightleft");
      var rightright = new Node("rightright");

      tree.add(left)
      tree.add(right)
      tree.remove(right) // note: remove
      tree.add(right)

      left.add(leftleft);
      left.add(leftright);

      right.add(rightleft);
      right.add(rightright);

      traverse(1, tree);

      log.show();
    }

    run();
  </script>
</body>

</html>