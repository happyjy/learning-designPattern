<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>

<body>

  <script>
    /*

      # def
        * 프록시 패턴은 다른 개체에 대신할 개체를 제공하고 이 다른 개체에 대한 액세스를 제어합니다.
        
        * 객체 지향 프로그래밍에서 객체는 인터페이스(속성 및 메서드)를 통해 알리는 작업을 수행한다.
        * 이러한 개체의 클라이언트는 이 작업이 빠르고 효율적으로 수행되기를 원한다.
        * 그러나 객체가 심각하게 제한되어 책임을 다할 수 없는 상황이 있다.
        * 일반적으로 원격 리소스에 대한 종속성이 있거나 (네트워크 대기 시간이 발생 함) 개체를 로드하는 데 오랜 시간이 걸리는 경우에 발생한다.

        * 이와 같은 상황에서는 프록시 패턴을 적용하고 원본 객체를 '대기'하는 프록시 객체를 만든다.
        * 프록시는 요청을 대상 개체로 전달한다.
        * Proxy 개체의 인터페이스는 원래 개체와 동일하며 클라이언트는 실제 개체가 아닌 프록시를 처리하고 있다는 사실조차 인식하지 못할 수 있다.

      # Participants
        * Client
          - 생성될 객체를 "Clone"하기 위해서 "Prototype"에 요청한다. 
            : 이말은 즉 Prototype이 객체를 clone 한다.
        * Prototype
          - 클론할 인터페이스를 생성
          - CustomerPrototype function

        * Clones
          - Clone될 객체
          - Customer

      # 샘플 코드 설명
        * GeoCoder 객체는 Google Maps Geocoding 서비스를 시뮬레이션한다.
        * 지오 코딩에서 위치 (지구상의 한 장소)를 제공하면 위도/경도 (latlng)가 반환된다.
        * GeoCoder는 4개의 위치만 확인할 수 있지만 실제로는 국가, 도시 및 거리가 포함되어 있기 때문에 수백만 개가 있다.

        * 프로그래머는 GeoCoder가 상대적으로 느리기 때문에 Proxy객체를 구현하기로 결정했다
        * 프록시 개체를 GeoProxy라고 한다.
        * 동일한 위치에 대해 반복되는 요청이 많이 들어오는 것으로 알려져 있다.
        * [POINT] GeoProxy는 속도를 높이기 위해 자주 요청되는 위치를 캐시합니다. GeoProxy의 geocahe 객체!
        * 위치가 아직 캐시되지 않은 경우 실제 GeoCoder 서비스로 이동하여 결과를 캐시에 저장합니다.

        * 여러 도시 위치가 조회되고 이들 중 다수는 동일한 도시에 대한 것이다.
        * GeoProxy는 이러한 호출을 지원하면서 캐시를 구축한다.
        * 결국 GeoProxy는 getLatLng으로 11개의 요청을 처리했지만 GeoCoder로 3번만 요청 했다. 
        * 클라이언트 프로그램에는 프록시 개체에 대한 정보가 없다.(표준 getLatLng 메서드를 사용하여 동일한 인터페이스를 호출 한다.
        
      # Question
        * [ ] 이걸 어덯게 활용하는 걸가? 

      # STUDY
        * function에 this에 선언한 properties들은 
        new 키워드로 객체를 생성시 생성된 객체의 바로 하위 property에 등록 된다.
      

    */
    function CustomerPrototype(proto) {
      this.proto = proto;

      this.clone = function () {
        var customer = new Customer();

        customer.first = proto.first;
        customer.last = proto.last;
        customer.status = proto.statust;

        return customer;
      }
    }

    function Customer(info = {}) {
      this.first = info.first;
      this.last = info.last;
      this.status = info.status;

      this.say = function () {
        console.log(`# NAME: ${this.first} ${this.last}, # STATUS: ${this.status}`)
      }
    }

    function run() {
      var proto = new Customer({ first: "n/a", last: "n/a", status: "pending" });
      var prototype = new CustomerPrototype(proto);

      var customer = prototype.clone();
      customer.say();
    }

    run()

  </script>
</body>

</html>